#!/usr/bin/env bash
# written by Kyle Butler
# requires jq to be installed
# pulls the vulnerability data from the Prisma Cloud Code security section of the platform and creates a csv similar to the image vulnerability report
# no user configuration needed
# will take a while to complete


source ./secrets/secrets
source ./func/func.sh


REPORT_DATE=$(date  +%m_%d_%y)

retrieve_token () {
AUTH_PAYLOAD=$(cat <<EOF
{"username": "$PC_ACCESSKEY", "password": "$PC_SECRETKEY"}
EOF
)


PC_JWT_RESPONSE=$(curl --request POST \
                       --url "$PC_APIURL/login" \
                       --header 'Accept: application/json; charset=UTF-8' \
                       --header 'Content-Type: application/json; charset=UTF-8' \
                       --data "${AUTH_PAYLOAD}")



PC_JWT=$(printf %s "$PC_JWT_RESPONSE" | jq -r '.token' )
}

retrieve_token





REPOSITORY_LIST_REQUEST=$(curl --request GET \
                               --url "$PC_APIURL/code/api/v1/repositories" \
                               --header "content-type: applicaion/json; charset=UTF-8" \
                               --header "x-redlock-auth: $PC_JWT")


printf '%s' "$REPOSITORY_LIST_REQUEST" | jq '[.[] |{source: .source, ownerRepository: (.owner + "/" + .repository)}]' > ./temp/repository_list_$REPORT_DATE.json



REPOSITORY_LIST_ARRAY=( $(cat ./temp/repository_list_$REPORT_DATE.json | jq -r '.[]| .ownerRepository' ) )

REPO_INDEX=$( cat temp/repository_list_$REPORT_DATE.json | jq '.|length')

for index in $(seq 0 $(($REPO_INDEX -1))); do \

mkdir ./temp/$(printf '%05d' "$index")

SOURCE_TYPE=$(cat temp/repository_list_$REPORT_DATE.json | jq --argjson index "$index" '.[$index] | .source')
REPOSITORY=$(cat temp/repository_list_$REPORT_DATE.json | jq --argjson index "$index" '.[$index] | .ownerRepository')

ERROR_FILES_PAYLOAD=$(cat <<EOF
{
     "sourceTypes": [
          $SOURCE_TYPE
     ],
     "repository": $REPOSITORY,
     "categories": ["Vulnerabilities"]
}
EOF
)


curl -s --request POST \
        --url "$PC_APIURL/code/api/v1/errors/files" \
        --header "authorization: $PC_JWT" \
        --header 'content-type: application/json' \
        --data "$ERROR_FILES_PAYLOAD" > ./temp/error_file_response_$(printf '%05d' "$index").json

FILE_PATH_ARRAY=($(cat ./temp/error_file_response_$(printf '%05d' "$index").json | jq '.data[].filePath' ))

FILE_ERROR_COUNT_ARRAY=($(cat ./temp/error_file_response_$(printf '%05d' "$index").json | jq '.data[].errorsCount' ))

if ! (( $index % 100)); then \

  retrieve_token

fi

for file_path in "${!FILE_PATH_ARRAY[@]}"; do

ERROR_FILE_PATH_PAYLOAD=$(cat <<EOF
{
  "sourceTypes": [
    $SOURCE_TYPE
  ],
    "repository": $REPOSITORY,
    "filePath": ${FILE_PATH_ARRAY[file_path]},
    "categories": ["Vulnerabilities"]
  }
EOF
)

for offset in $(seq 0 10 "${FILE_ERROR_COUNT_ARRAY[file_path]}"); do

echo "${FILE_ERROR_COUNT_ARRAY[file_path]} total errors in ${FILE_PATH_ARRAY[file_path]}. Request offset: $offset"

curl -s --request POST \
     --url "$PC_APIURL/code/api/v1/errors/file?limit=10&offset=$offset" \
     --header "authorization: $PC_JWT" \
     --header 'content-type: application/json' \
     --data "$ERROR_FILE_PATH_PAYLOAD" > "./temp/$(printf '%05d' "$index")/$(printf '%05d%05d' "$file_path" "$offset").json" &
   done
  done

wait
echo "collecting error data please wait for this to finish"


if [ -d "./temp/$(printf '%05d' $index)" ]
then
  if [ "$(ls -A ./temp/$(printf '%05d' $index))" ]; then
   cat ./temp/$(printf '%05d' $index)/*.json | jq --arg REPO "${REPOSITORY_LIST_ARRAY[$index]}" '.data[] | {repo: $REPO, fileMetadataUuid, filePath, sourceType, frameworkType, status, author, date, runtimeId, errorId, scannerType}' > "./temp/finished_$(printf '%05d' "$index").json"
  else
    echo "${REPOSITORY_LIST_ARRAY[repo]} has no errors"
 fi
else
 echo "Directory ./temp/$repo not found."
fi


done

wait

cat ./temp/finished_* > ./temp/all_errors_$REPORT_DATE.json


PACKAGE_ARRAY=($(cat ./temp/all_errors_$REPORT_DATE.json | jq -r '. | select(.frameworkType == "Vulnerabilities" and .status == "OPEN" ) | .fileMetadataUuid'))

mkdir ./temp/package


for package in "${!PACKAGE_ARRAY[@]}"; do \

if ! (( $package % 100)); then \
  retrieve_token
fi

mkdir ./temp/package/$(printf '%05d' "$package")

  for ((package_offset=0; ; package_offset=package_offset+50)); do \
    echo "making request to: $PC_APIURL/code/api/v1/vulnerabilities/packages/files/${PACKAGE_ARRAY[package]}?offset=$package_offset&limit=50"
    curl --request GET \
         --url "$PC_APIURL/code/api/v1/vulnerabilities/packages/files/${PACKAGE_ARRAY[package]}?offset=$package_offset&limit=50" \
         --header "authorization: $PC_JWT" \
         --header "Content-Type: application/json" > ./temp/package/$(printf '%05d' "$package")/$(printf '%05d%05d' "$package" "$package_offset").json
    package_pagination=$(cat ./temp/package/$(printf '%05d' "$package")/$(printf '%05d%05d' "$package" "$package_offset").json | jq '.hasNext')
    if [[ "$package_pagination" == false ]]
      then break
    fi
  done
  cat ./temp/package/$(printf '%05d' "$package")/*.json > ./temp/package/finished_$(printf '%05d' "$package").json
done

PACKAGE_CVE_ARRAY=($(cat ./temp/package/finished_*.json | jq -r '.packages[].packageId' ))

mkdir ./temp/cve

echo "Pulling all the vulnerability data. Please wait"

for package_cve in "${!PACKAGE_CVE_ARRAY[@]}"; do \

if ! (( $package_cve % 100)); then \
  retrieve_token
fi

  curl -s --request GET \
       --url "$PC_APIURL/code/api/v1/vulnerabilities/packages/${PACKAGE_CVE_ARRAY[package_cve]}/cves" \
       --header 'Accept: application/json' \
       --header "authorization: $PC_JWT" > ./temp/cve/$(printf '%05d' "$package_cve").json&

done
wait

echo "Combining data this will take a while. Please don't quit the process"

cat ./temp/cve/*.json | jq '.data[] | {packageId: .causePackageId, cveStatus, cveId, cvss, uuid, packageName, packageVersion, description, fixVersion, link, publishedDate, severity, vector, violationId, resourceId, sourceId, riskFactorDos: .riskFactors.DoS, riskFactorHasFix: .riskFactors.HasFix, riskFactorAttackVector: .riskFactors.AttackVector, riskFactorAttackComplexity: .riskFactors.AttackComplexity, riskFactorRecentVulnerability: .riskFactors.RecentVulnerability, registryUrl, isPrivateFix}' > "./temp/finished_cve_$REPORT_DATE.json"

cat ./temp/package/finished_*.json | jq '.packages[] | {packageId, packageName, packageVersion, packageLicenses: (.packageLicenses| @sh), fileMetadataId}' > "./temp/finished_package_data_$REPORT_DATE.json"

cat ./temp/all_errors_$REPORT_DATE.json | jq '[inputs] | map({repo, filePath, sourceType, frameworkType, status, author, date, runtimeId, errorId, scannerType, fileMetaDataUuid: [(.fileMetadataUuid as $fileMetadataId | $package_data |..| select(.fileMetadataId? and .fileMetadataId==$fileMetadataId))]})' --slurpfile package_data "./temp/finished_package_data_$REPORT_DATE.json" > "./temp/combined_package_error_$REPORT_DATE.json"

cat ./temp/combined_package_error_$REPORT_DATE.json | jq '[.[] | {repo, filePath, sourceType, frameworkType, status, author, date, runtimeId, errorId, scannerType, package: .fileMetaDataUuid[]} | {repo, filePath, sourceType, frameworkType, status, author, date, runtimeId, errorId, scannerType, packageId: .package.packageId, packageName: .package.packageName, packageVersion: .package.packageVersion, packageLicenses: .package.packageLicenses, fileMetadataId: .package.fileMetadataId }]' > "./temp/finished_combined_package_error_$REPORT_DATE.json"

cat ./temp/finished_combined_package_error_$REPORT_DATE.json | jq '. |map({repo, filePath, sourceType, frameworkType, status, author, date, runtimeId, errorId, scannerType, packageName, packageVersion, packageLicenses, fileMetadataId, packageId,packageIdMatch: [(.packageId as $packageId | $cve_data |..| select( .packageId? and .packageId==$packageId))]})' --slurpfile cve_data ./temp/finished_cve_$REPORT_DATE.json > "./temp/combined_cve_package_error_$REPORT_DATE.json"

cat ./temp/combined_cve_package_error_$REPORT_DATE.json | jq -r '[.[]| {repo, filePath, sourceType, frameworkType, status, author, date, runtimeId, errorId, scannerType, packageName, packageVersion, packageLicenses, fileMetadataId, packageId, cveData: .packageIdMatch[]} | {repo, filePath, sourceType, frameworkType, status, author, date, runtimeId, errorId, scannerType, packageName, packageVersion, packageLicenses, fileMetadataId, packageId, cveStatus: .cveData.cveStatus, cveId: .cveData.cveId, cvss: .cveData.cvss, packageName: .cveData.packageName, packageVersion: .cveData.packageVersion, description: .cveData.description, fixVersion: .cveData.fixVersion, link: .cveData.link, publishedDate: .cveData.publishedDate, severity: .cveData.severity, vector: .cveData.vector, violationId: .cveData.violationId, resourceId: .cveData.resourceId, sourceId: .cveData.sourceId, riskFactorDos: .cveData.riskFactorDos, riskFactorHasFix: .cveData.riskFactorHasFix, riskFactorAttackVector: .cveData.riskFactorAttackVector, riskFactorAttackComplexity: .cveData.riskFactorAttackComplexity, registryUrl: .cveData.registryUrl}] | map({repo, filePath, sourceType, frameworkType, status, author, date, runtimeId, errorId, scannerType, packagename, packageVersion, packageLicenses, fileMetadataId, packageid, cveStatus, cveId, cvss, description, fixVersion, link, publishedDate, severity, vector, violationId, resourceid, sourceId, riskFactorDos, riskFactorHasFix, riskFactorAttackVector, riskFactorAttackComplexity, registryUrl})| (first | keys_unsorted) as $keys | map([to_entries[] | .value]) as $rows | $keys,$rows[] | @csv' > ./reports/code_security_vuln_report_$REPORT_DATE.csv

printf '\n%s\n' "All done your report is in the reports directory saved as: ./reports/code_security_vuln_report_$REPORT_DATE.csv"

{
rm -rf ./temp/*
}

exit
